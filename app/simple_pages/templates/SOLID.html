{% extends "base.html" %}
<article>{% block content %}
    <h1>SOLID</h1>
    <h2><strong>S.O.L.I.D Principles explained in Python with examples.</strong></h2>
    <p>SOLID is a mnemonic abbreviation for a set of design principles created for software development in object-oriented languages. The principles in <strong>SOLID</strong> are intended to foster simpler, more robust and updatable code from software developers. Each letter in SOLID corresponds to a principle for development:</p>
    <p>When implemented properly it makes your code more <strong>extendable, logical and easier to read.</strong></p>
    <p>To understand <strong>SOLID</strong> principles, you have to know the use of the interface clearly.</p>
    <p>I’m going to try to explain <strong>SOLID</strong> Principles in Python in simple way so that it’s easy for beginners to understand. It would be very easy to just take the examples provided and apply them to Python.</p>
    <p>Let’s go through each principle one by one:</p>
    <h2><strong>1. Single Responsibility Principle</strong></h2>
    <p>The Single Responsibility Principle requires that a class should have only one job. So if a class has more than one responsibility, it becomes coupled. A change to one responsibility results to modification of the other responsibility.</p>
    <img src="../../static/images/SOLIIDs.png" alt="Codes" width="644" height="352">
    <p>We have a User class which is responsible for both the user properties and user database management. If the application changes in a way that it affect database management functions. The classes that make use of User properties will have to be touched and recompiled to compensate for the new changes. It’s like a domino effect, touch one card it affects all other cards in line.</p>
    <p>So we simply split the class, we create another class that will handle the one responsibility of storing an user to a database:</p>
    <img src="../../static/images/SOLIDs2.png" alt="Codes2" width="350" height="550">
    <p>A common solution to this dilemma is to apply the Façade pattern. User class will be the Facade for user database management and user properties management.</p>
    <h2><strong>2.Open-Closed Principle</strong></h2>
    <p>Software entities(Classes, modules, functions) should be open for extension, not modification.</p>
    <p>Let’s imagine you have a store, and you give a discount of 20% to your favorite customers using this class: When you decide to offer double the 20% discount to VIP customers. You may modify the class like this:</p>
    <img src="../../static/images/SOLIDs3.png" alt="Codes3" width="350" height="550">
    <p>No, this fails the OCP principle. OCP forbids it. If we want to give a new percent discount maybe, to a different type of customers, you will see that a new logic will be added. To make it follow the OCP principle, we will add a new class that will extend the Discount. In this new class, we would implement its new behavior:</p>
    <img src="../../static/images/SOLIDs4.png" alt="Codes4" width="350" height="550">
    <p>If you decide 80% discount to super VIP customers, it should be like this:</p>
    <p>Extension without modification.</p>
    <p></p>
    <p></p>
    <p></p>



{% endblock %}
</article>
